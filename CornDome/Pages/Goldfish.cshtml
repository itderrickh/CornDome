@page
@using System.Text.Json
@model CornDome.Pages.GoldfishModel
@{
    ViewData["RenderMode"] = "wide";
}

@if (Model.QueryDeck.Landscapes.Count < 4)
{
    <span> Deck does not have required amount of landscapes</span>
}
else if (Model.QueryDeck.Cards.Count < 40)
{
    <span>Deck does not have enough cards</span>
}
else
{
    <div class="game-board">
        <div id="deck" class="deck">
            Deck
        </div>

        <cd-landscape id="landscape1" class="landscape drop-landscape" data-landscape="landscape1" alt-text="@Model.QueryDeck.Landscapes[0].Name" landscape-image="@("/CardImages/" + @Model.QueryDeck.Landscapes[0].ImageUrl)"></cd-landscape>
        <cd-landscape id="landscape2" class="landscape drop-landscape" data-landscape="landscape2" alt-text="@Model.QueryDeck.Landscapes[1].Name" landscape-image="@("/CardImages/" + @Model.QueryDeck.Landscapes[1].ImageUrl)"></cd-landscape>
        <cd-landscape id="landscape3" class="landscape drop-landscape" data-landscape="landscape3" alt-text="@Model.QueryDeck.Landscapes[2].Name" landscape-image="@("/CardImages/" + @Model.QueryDeck.Landscapes[2].ImageUrl)"></cd-landscape>
        <cd-landscape id="landscape4" class="landscape drop-landscape" data-landscape="landscape4" alt-text="@Model.QueryDeck.Landscapes[3].Name" landscape-image="@("/CardImages/" + @Model.QueryDeck.Landscapes[3].ImageUrl)"></cd-landscape>

        <div id="spellzone" ondragover="event.preventDefault()">
            <span>Spell Zone</span>
            <div class="cardslot"></div>
        </div>

        <div id="discard">
            <span>Discard</span>
            <div class="cardslot"></div>
        </div>
    </div>

    <div id="control-board">
        <div id="lifetotal">
            
        </div>
        <div id="hand" style="">
        </div>
    </div>
    

    <context-menu target-class="card" id="cardMenu"></context-menu>
    <context-menu target-id="deck" id="deckMenu"></context-menu>
    <context-menu target-id="spellzone" id="spellzoneMenu"></context-menu>
}

@section Styles {
    <style>
        .game-board, #control-board {
            display: flex;
            justify-content: center;
            gap: 20px;
            width: 90%;
            margin: 0 auto 10px auto;
        }


        #hand {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            flex-basis: 80%;
        }

        #lifetotal {
            flex-basis: 20%;
        }

        #deck, #discard, #spellzone {
            width: 200px;
            border: 1px solid white;
            border-radius: 3px;
        }

        .card-image {
        
        }

        #spellzone, #discard, #deck {
            display: block;
            position: relative;
            padding: 5px;
        }

        #spellzone .cardslot, #discard .cardslot {
            margin-top: 10px;
        }

        .landscape {
            display: block;
        }

        .drop-landscape {
            position: relative;
        }

        #hand .card {
            width: 17%;
        }

        .flooped {
            transform: rotate(-0.25turn);
        }
    </style>
}

@section Scripts {
    <script src="~/js/goldfish/contextMenu.js"></script>
    <script src="~/js/goldfish/landscape.js"></script>

    <script>
        const cardMenu = document.getElementById('cardMenu');
        const deckMenu = document.getElementById('deckMenu');
        const spellzoneMenu = document.getElementById('spellzoneMenu');
        
    </script>
    <script>
        var deck = JSON.parse('@(Html.Raw(JsonSerializer.Serialize(Model.QueryDeck.Cards)))');
        var zones = {
            hand: document.getElementById('hand'),
            discard: document.getElementById('discard'),
            deck: document.getElementById('deck')
        };

        var applicationState = {
            hand: [],
            discard: [],
            deck: [],
            field: {
                spellZone: null,
                landscape1: {
                    card: {
                        flooped: false,
                        damage: 0,
                        data: null
                    },
                    building: {
                        flooped: false,
                        data: null
                    }
                },
                landscape2: {
                    card: {
                        flooped: false,
                        damage: 0,
                        data: null
                    },
                    building: {
                        flooped: false,
                        data: null
                    }
                },
                landscape3: {
                    card: {
                        flooped: false,
                        damage: 0,
                        data: null
                    },
                    building: {
                        flooped: false,
                        data: null
                    }
                },
                landscape4: {
                    card: {
                        flooped: false,
                        damage: 0,
                        data: null
                    },
                    building: {
                        flooped: false,
                        data: null
                    }
                }
            }
        };

        function render() {
            zones.hand.innerHTML = "";
            for (let handCard of applicationState.hand) {
                let template = handCardTemplate(handCard, false);
                zones.hand.insertAdjacentHTML("beforeend", template);
            }

            if (applicationState.field.spellZone !== null) {
                var spellzone = document.querySelector("#spellzone .cardslot");
                spellzone.innerHTML = "";
                let template = handCardTemplate(applicationState.field.spellZone, false);
                spellzone.insertAdjacentHTML("beforeend", template);
            } else {
                var spellzone = document.querySelector("#spellzone .cardslot");
                spellzone.innerHTML = "";
            }

            if (applicationState.discard.length > 0) {
                var discardPile = document.querySelector("#discard .cardslot");
                discardPile.innerHTML = "";
                let template = handCardTemplate(applicationState.discard[applicationState.discard.length - 1], false);
                discardPile.insertAdjacentHTML("beforeend", template);
            }
        }

        function drawCard() {
            if (applicationState.deck.length > 0)
                applicationState.hand.push(applicationState.deck.pop());
            render();
            handlers();
        }

        function shuffle(array) {
            let currentIndex = array.length;

            // While there remain elements to shuffle...
            while (currentIndex != 0) {

                // Pick a remaining element...
                let randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
        }

        function handlers() {
            const elements = document.querySelectorAll("#hand .card");

            for (let handCard of elements) {
                handCard.removeEventListener("dragstart", dragstartHandler);
                handCard.addEventListener("dragstart", dragstartHandler);
            }

            elements.forEach((card) => {
                card.addEventListener('contextmenu', (event) => {
                    event.preventDefault();  // Disable default browser context menu
                    cardMenu.showMenu(event.pageX, event.pageY, event.target);
                });
            });

            // Context Menus
            const cardMenuItems = [
                { label: 'Discard', action: discardFromHand }
            ];
            cardMenu.setMenuItems(cardMenuItems);
            const deckMenuItems = [
                { label: 'Draw', action: drawCard },
                { label: 'Shuffle', action: null }
            ];
            deckMenu.setMenuItems(deckMenuItems);

            zones.deck.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                deckMenu.showMenu(event.pageX, event.pageY, event.target);
            });

            const spellzoneMenuItems = [
                { label: 'Discard', action: discardFromSpellZone }
            ];
            spellzoneMenu.setMenuItems(spellzoneMenuItems);

            const spellzone = document.getElementById('spellzone');
            spellzone.removeEventListener("drop", spellzoneDrop);
            spellzone.addEventListener('drop', spellzoneDrop);
            spellzone.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                spellzoneMenu.showMenu(event.pageX, event.pageY, event.target);
            });
        }

        function discardFromSpellZone() {
            var card = applicationState.field.spellZone;
            applicationState.discard.push(card);
            applicationState.field.spellZone = null;

            render();
            handlers();
        }

        function discardFromHand(target) {
            var id = parseInt(target.parentElement.dataset.id, 10);
            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(id);
            var card = applicationState.hand.splice(locationInHand, 1);
            applicationState.discard.push(card[0]);

            render();
            handlers();
        }

        function handCardTemplate(card, flooped) {
            var data = encodeURIComponent(JSON.stringify(card));
            var floopClass = flooped ? 'flooped' : '';
            return `
                <div draggable="true"
                    class="card ${floopClass}"
                    data-id="${card.id}"
                    data-card="${data}">
                            <img class="deck-card-image" alt="${card.name}" style = "width: 100%;" src="/CardImages/${card.imageurl}" />
                 </div>
            `;
        }

        function dragstartHandler(ev) {
            // Add the target element's id to the data transfer object
            ev.dataTransfer.setData("text/plain", ev.target.parentElement.dataset.card);
        }

        function spellzoneDrop(ev) {
            ev.preventDefault();
            const rawData = ev.dataTransfer.getData('text');
            const card = JSON.parse(decodeURIComponent(rawData));

            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(card['id']);
            applicationState.hand.splice(locationInHand, 1);

            applicationState.field.spellZone = card;
            render();
            handlers();
        }

        document.addEventListener('landscape-card-drop', (event) => {
            const cardData = event.detail.cardData;
            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(cardData['id']);
            applicationState.hand.splice(locationInHand, 1);
            render();
            handlers();
        });

        window.addEventListener("DOMContentLoaded", () => {
            applicationState.deck = deck;

            shuffle(applicationState.deck);
            for (var i = 0; i < 5; i++) {
                applicationState.hand.push(applicationState.deck.pop());
            }

            render();
            handlers();
        });
    </script>
}