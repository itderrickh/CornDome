@page
@using System.Text.Json
@model CornDome.Pages.GoldfishModel
@{
    ViewData["RenderMode"] = "wide";
    ViewData["Title"] = "Goldfish";
}

@if (Model.QueryDeck.Landscapes.Count < 4)
{
    <span> Deck does not have required amount of landscapes</span>
}
else if (Model.QueryDeck.Cards.Count < 40)
{
    <span>Deck does not have enough cards</span>
}
else
{
    <div class="game-board">
        <div id="deck" class="deck">
            <span>Deck (<span id="deck-size"></span>)</span>
            <div class="cardslot">
                <div class="card-placeholder">
                    <img src="/img/lifebackground.jpg" />
                </div>
            </div>
        </div>

        <div style="display: flex; position: relative; flex-wrap: wrap;">
            <div style="display: flex; width: 100%;">
                <cd-landscape id="landscape1" class="landscape drop-landscape" data-landscape="landscape1" alt-text="@Model.QueryDeck.Landscapes[0].Name" landscape-image="@("/CardImages/" + @Model.QueryDeck.Landscapes[0].ImageUrl)"></cd-landscape>
                <cd-landscape id="landscape2" class="landscape drop-landscape" data-landscape="landscape2" alt-text="@Model.QueryDeck.Landscapes[1].Name" landscape-image="@("/CardImages/" + @Model.QueryDeck.Landscapes[1].ImageUrl)"></cd-landscape>
                <cd-landscape id="landscape3" class="landscape drop-landscape" data-landscape="landscape3" alt-text="@Model.QueryDeck.Landscapes[2].Name" landscape-image="@("/CardImages/" + @Model.QueryDeck.Landscapes[2].ImageUrl)"></cd-landscape>
                <cd-landscape id="landscape4" class="landscape drop-landscape" data-landscape="landscape4" alt-text="@Model.QueryDeck.Landscapes[3].Name" landscape-image="@("/CardImages/" + @Model.QueryDeck.Landscapes[3].ImageUrl)"></cd-landscape>
            </div>

            <div style="display: flex; width: 100%;">
                <div style="width: 25%;" id="building1" class="building" ondragover="event.preventDefault()"><div class="card-drop"></div></div>
                <div style="width: 25%;" id="building2" class="building" ondragover="event.preventDefault()"><div class="card-drop"></div></div>
                <div style="width: 25%;" id="building3" class="building" ondragover="event.preventDefault()"><div class="card-drop"></div></div>
                <div style="width: 25%;" id="building4" class="building" ondragover="event.preventDefault()"><div class="card-drop"></div></div>
            </div>
        </div>  

        <div id="spellzone" ondragover="event.preventDefault()">
            <span>Spell Zone</span>
            <div class="cardslot"></div>
        </div>

        <div id="discard">
            <span>Discard</span>
            <div class="cardslot"></div>
        </div>
    </div>

    <div id="control-board">
        <div id="lifetotal">
            
        </div>
        <div id="hand" style="">
        </div>
    </div>
    

    <context-menu target-class="card" id="cardMenu"></context-menu>
    <context-menu target-id="deck" id="deckMenu"></context-menu>
    <context-menu target-id="spellzone" id="spellzoneMenu"></context-menu>
}

@section Styles {
    <style>
        .game-board, #control-board {
            display: flex;
            justify-content: center;
            gap: 20px;
            width: 95%;
            margin: 0 auto 10px auto;
        }

        .building, .landscape {
            height: 300px;
            width: 200px;
            border: 1px solid white;
            border-radius: 3px;
        }

        #hand {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            flex-basis: 80%;
        }

        #lifetotal {
            flex-basis: 20%;
        }

        #deck, #discard, #spellzone {
            width: 15%;
            border: 1px solid white;
            border-radius: 3px;
        }

        .card-placeholder {
            position: relative;
            display: flex;
            flex-direction: column;
            min-width: 0;
            word-wrap: break-word;
            background-color: #fff;
            background-clip: border-box;
            border: 1px solid rgba(0,0,0,.125);
            border-radius: .25rem;
        }

        #spellzone, #discard, #deck {
            display: block;
            position: relative;
            padding: 5px;
        }

        #spellzone .cardslot, #discard .cardslot, #deck .cardslot {
            margin-top: 10px;
        }

        .landscape {
            display: block;
            width: 25%;
        }


        #hand .card {
            width: 17%;
        }

        .flooped {
            transform: rotate(-0.25turn);
        }

        .building {
            position: relative;
            height: 200px;
            width: 133px;
        }

        .card-drop {
            position: absolute;
            margin-left: auto;
            margin-right: auto;
            left: 0;
            right: 0;
            text-align: center;
            top: 0;
            height: 60%;
            width: 60%;
        }
    </style>
}

@section Scripts {
    <script src="~/js/goldfish/contextMenu.js"></script>
    <script src="~/js/goldfish/landscape.js"></script>

    <script>
        const cardMenu = document.getElementById('cardMenu');
        const deckMenu = document.getElementById('deckMenu');
        const spellzoneMenu = document.getElementById('spellzoneMenu');
        
    </script>
    <script>
        var deck = JSON.parse('@(Html.Raw(JsonSerializer.Serialize(Model.QueryDeck.Cards)))');
        var zones = {
            hand: document.getElementById('hand'),
            discard: document.getElementById('discard'),
            deck: document.getElementById('deck'),
            building1: document.querySelector('#building1 .card-drop'),
            building2: document.querySelector('#building2 .card-drop'),
            building3: document.querySelector('#building3 .card-drop'),
            building4: document.querySelector('#building4 .card-drop'),
        };

        var applicationState = {
            hand: [],
            discard: [],
            deck: [],
            field: {
                spellZone: null,
                landscape1: {
                    card: null
                },
                building1: {
                    flooped: false,
                    data: null
                },
                landscape2: {
                    card: null
                },
                building2: {
                    flooped: false,
                    data: null
                },
                landscape3: {
                    card: null
                },
                building3: {
                    flooped: false,
                    data: null
                },
                landscape4: {
                    card: null
                },
                building4: {
                    flooped: false,
                    data: null
                },
            }
        };

        function render() {
            var deckSize = document.getElementById('deck-size');

            deckSize.textContent = applicationState.deck.length;
            if (applicationState.deck.length === 0) {
                document.querySelector('#deck .cardslot img').src = "";
            }

            zones.hand.innerHTML = "";
            for (let handCard of applicationState.hand) {
                let template = handCardTemplate(handCard, false);
                zones.hand.insertAdjacentHTML("beforeend", template);
            }

            if (applicationState.field.spellZone !== null) {
                var spellzone = document.querySelector("#spellzone .cardslot");
                spellzone.innerHTML = "";
                let template = handCardTemplate(applicationState.field.spellZone, false);
                spellzone.insertAdjacentHTML("beforeend", template);
            } else {
                var spellzone = document.querySelector("#spellzone .cardslot");
                spellzone.innerHTML = "";
            }

            if (applicationState.discard.length > 0) {
                var discardPile = document.querySelector("#discard .cardslot");
                discardPile.innerHTML = "";
                let template = handCardTemplate(applicationState.discard[applicationState.discard.length - 1], false);
                discardPile.insertAdjacentHTML("beforeend", template);
            }

            if (applicationState.field.building1.data !== null) {
                zones.building1.innerHTML = "";
                let template = handCardTemplate(applicationState.field.building1.data, false);
                zones.building1.insertAdjacentHTML("beforeend", template);
            }

            if (applicationState.field.building2.data !== null) {
                zones.building2.innerHTML = "";
                let template = handCardTemplate(applicationState.field.building2.data, false);
                zones.building2.insertAdjacentHTML("beforeend", template);
            }

            if (applicationState.field.building3.data !== null) {
                zones.building3.innerHTML = "";
                let template = handCardTemplate(applicationState.field.building3.data, false);
                zones.building3.insertAdjacentHTML("beforeend", template);
            }

            if (applicationState.field.building4.data !== null) {
                zones.building4.innerHTML = "";
                let template = handCardTemplate(applicationState.field.building4.data, false);
                zones.building4.insertAdjacentHTML("beforeend", template);
            }
        }

        function drawCard() {
            if (applicationState.deck.length > 0)
                applicationState.hand.push(applicationState.deck.pop());
            render();
            handlers();
        }

        function shuffle(array) {
            let currentIndex = array.length;

            // While there remain elements to shuffle...
            while (currentIndex != 0) {

                // Pick a remaining element...
                let randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
        }

        function handlers() {
            const elements = document.querySelectorAll("#hand .card");

            for (let handCard of elements) {
                handCard.removeEventListener("dragstart", dragstartHandler);
                handCard.addEventListener("dragstart", dragstartHandler);
            }

            elements.forEach((card) => {
                card.addEventListener('contextmenu', (event) => {
                    event.preventDefault();  // Disable default browser context menu
                    cardMenu.showMenu(event.pageX, event.pageY, event.target);
                });
            });

            // Context Menus
            const cardMenuItems = [
                { label: 'Discard', action: discardFromHand }
            ];
            cardMenu.setMenuItems(cardMenuItems);
            const deckMenuItems = [
                { label: 'Draw', action: drawCard },
                { label: 'Shuffle', action: null }
            ];
            deckMenu.setMenuItems(deckMenuItems);

            zones.deck.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                deckMenu.showMenu(event.pageX, event.pageY, event.target);
            });

            const spellzoneMenuItems = [
                { label: 'Discard', action: discardFromSpellZone }
            ];
            spellzoneMenu.setMenuItems(spellzoneMenuItems);

            const spellzone = document.getElementById('spellzone');
            spellzone.removeEventListener("drop", spellzoneDrop);
            spellzone.addEventListener('drop', spellzoneDrop);
            spellzone.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                spellzoneMenu.showMenu(event.pageX, event.pageY, event.target);
            });

            const building1 = document.getElementById('building1');
            building1.removeEventListener('drop', building1Drop);
            building1.addEventListener('drop', building1Drop);

            const building2 = document.getElementById('building2');
            building2.removeEventListener('drop', building2Drop);
            building2.addEventListener('drop', building2Drop);

            const building3 = document.getElementById('building3');
            building3.removeEventListener('drop', building3Drop);
            building3.addEventListener('drop', building3Drop);

            const building4 = document.getElementById('building4');
            building4.removeEventListener('drop', building4Drop);
            building4.addEventListener('drop', building4Drop);
        }

        function discardFromSpellZone() {
            var card = applicationState.field.spellZone;
            applicationState.field.spellZone = null;

            document.dispatchEvent(new CustomEvent('discard-card', { detail: card }));

            render();
            handlers();
        }

        function discardFromHand(target) {
            var id = parseInt(target.parentElement.dataset.id, 10);
            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(id);
            var card = applicationState.hand.splice(locationInHand, 1);

            document.dispatchEvent(new CustomEvent('discard-card', { detail: card[0] }));

            render();
            handlers();
        }

        function handCardTemplate(card, flooped) {
            var data = encodeURIComponent(JSON.stringify(card));
            var floopClass = flooped ? 'flooped' : '';
            return `
                <div draggable="true"
                    class="card ${floopClass}"
                    data-id="${card.id}"
                    data-card="${data}">
                            <img class="deck-card-image" alt="${card.name}" style = "width: 100%;" src="/CardImages/${card.imageurl}" />
                 </div>
            `;
        }

        function dragstartHandler(ev) {
            // Add the target element's id to the data transfer object
            ev.dataTransfer.setData("text/plain", ev.target.parentElement.dataset.card);
        }

        function spellzoneDrop(ev) {
            ev.preventDefault();
            const rawData = ev.dataTransfer.getData('text');
            const card = JSON.parse(decodeURIComponent(rawData));

            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(card['id']);
            applicationState.hand.splice(locationInHand, 1);

            applicationState.field.spellZone = card;
            render();
            handlers();
        }

        function building1Drop(ev) {
            ev.preventDefault();
            const rawData = ev.dataTransfer.getData('text');
            const card = JSON.parse(decodeURIComponent(rawData));

            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(card['id']);
            applicationState.hand.splice(locationInHand, 1);

            applicationState.field.building1.data = card;
            render();
            handlers();
        }

        function building2Drop(ev) {
            ev.preventDefault();
            const rawData = ev.dataTransfer.getData('text');
            const card = JSON.parse(decodeURIComponent(rawData));

            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(card['id']);
            applicationState.hand.splice(locationInHand, 1);

            applicationState.field.building2.data = card;
            render();
            handlers();
        }

        function building3Drop(ev) {
            ev.preventDefault();
            const rawData = ev.dataTransfer.getData('text');
            const card = JSON.parse(decodeURIComponent(rawData));

            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(card['id']);
            applicationState.hand.splice(locationInHand, 1);

            applicationState.field.building3.data = card;
            render();
            handlers();
        }

        function building4Drop(ev) {
            ev.preventDefault();
            const rawData = ev.dataTransfer.getData('text');
            const card = JSON.parse(decodeURIComponent(rawData));

            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(card['id']);
            applicationState.hand.splice(locationInHand, 1);

            applicationState.field.building4.data = card;
            render();
            handlers();
        }

        document.addEventListener('landscape-card-drop', (event) => {
            const cardData = event.detail.cardData;
            var locationInHand = applicationState.hand.map(function (x) { return x.id; }).indexOf(cardData['id']);
            applicationState.hand.splice(locationInHand, 1);
            render();
            handlers();
        });

        document.addEventListener('discard-card', (event) => {
            const cardData = event.detail;
            applicationState.discard.push(cardData);

            render();
            handlers();
        });

        document.addEventListener('to-hand', (event) => {
            const cardData = event.detail;
            applicationState.hand.push(cardData);

            render();
            handlers();
        });

        window.addEventListener("DOMContentLoaded", () => {
            applicationState.deck = deck;

            shuffle(applicationState.deck);
            for (var i = 0; i < 5; i++) {
                applicationState.hand.push(applicationState.deck.pop());
            }

            render();
            handlers();
        });
    </script>
}